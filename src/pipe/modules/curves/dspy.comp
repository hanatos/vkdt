#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
#include "colourspaces.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 0) uniform global_t
{
  int frame, frame_cnt, hash, pad;
  vec4 col;
  vec4 hov;
} global;
layout(std140, set = 0, binding = 1) uniform params_t
{
  vec4 abcdr[8];
  vec4 abcdg[8];
  vec4 abcdb[8];
  vec4 xr0, xr1;
  vec4 xg0, xg1;
  vec4 xb0, xb1;
  vec4 yr0, yr1;
  vec4 yg0, yg1;
  vec4 yb0, yb1;
  int  cntr, cntg, cntb;
  int  sel;
  int  mode;
  int  chan;
  int  ychchan;
  int  edit;
  int  pad0, pad1;
  float ddr0, ddrn;
  float ddg0, ddgn;
  float ddb0, ddbn;
  vec4 vtx1[3], vtx2[3], vtx3[3], vtx4[3], vtx5[3], vtx6[3], vtx7[3], vtx8[3];
  vec4 abcd1[6], abcd2[6], abcd3[6], abcd4[6], abcd5[6], abcd6[6], abcd7[6], abcd8[6];
  float radius, edges;
} params;
layout(set = 1, binding = 0, std430) buffer buf_hist { uint  histogram[]; };
layout(set = 1, binding = 1) uniform writeonly image2D img_dspy;
#include "eq.glsl"
#include "spline.glsl"

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_dspy)))) return;

  int dep = 0; // depend on luma
  if(params.ychchan == 1 || params.ychchan == 3 || params.ychchan == 8) dep = 1; // depend on chroma
  if(params.ychchan == 2 || params.ychchan == 6 || params.ychchan == 7) dep = 2; // depend on hue

  float of0 = 0;//0.1; // extend range outside [0,1]?
  float off = of0 * imageSize(img_dspy).x;
  float x = ipos.x/float(imageSize(img_dspy).x - off);

  // draw histogram
  const uint hist_size = 256;
  vec4 rgba = vec4(0.05,0.05,0.05,1);
  vec2 tc = (ipos+0.5) / vec2(imageSize(img_dspy));
  const float h = 0.25*log(1.0+100000.0*histogram[int(clamp(tc.x*hist_size, 0, hist_size-1))]/float(histogram[hist_size]))-1.0;
  if(1.0-tc.y < h)
  {
    vec3 col = vec3(0.3);
    if(params.mode == 0)
    { // rgb
      col = vec3(params.chan==0?0.3:0.1,params.chan==1?0.3:0.1,params.chan==2?0.3:0.1);
    }
    else if(params.mode == 1)
    { // luminance
      col = vec3(0.3);
    }
    else // params.mode == 2
    { // ych
      float xx = x;
      if(params.ychchan == 0) xx = e2l(x);
      // if(dep == 0) col = ych2rgb(vec3(xx,0.0,0.0));
      // if(dep == 1) col = ych2rgb(vec3(0.5,xx,0.5));
      // if(dep == 2) col = ych2rgb(vec3(0.5,1.0,xx));
      if(dep == 0) col = oklsh_to_rec2020(vec3(xx,0.0,0.0));
      if(dep == 1) col = oklsh_to_rec2020(vec3(0.5,xx,0.5));
      if(dep == 2) col = oklsh_to_rec2020(vec3(0.5,1.0,xx));
    }
    rgba = vec4(col, 1.0);
  }
  else if(params.mode == 2)
  { // bg colour for ych mode
    float y = 0.5-tc.y;
    // float y = tc.y - 0.5;
    vec3 col;
    if     (params.ychchan == 0) col = oklsh_to_rec2020(vec3(e2l(max(x+y-0.5,0)),0,0)); // YY
    else if(params.ychchan == 1) col = oklsh_to_rec2020(vec3(0.5,max(0,x+y),0.0)); // CC
    else if(params.ychchan == 2) col = oklsh_to_rec2020(vec3(0.5,0.5,x+y)); // hh
    else if(params.ychchan == 3) col = oklsh_to_rec2020(vec3(y+0.5,x,0.0)); // YC
    else if(params.ychchan == 4) col = oklsh_to_rec2020(vec3(x,max(y+0.5,0),0.0)); // CY
    else if(params.ychchan == 5) col = oklsh_to_rec2020(vec3(x,0.5,y)); // hY
    else if(params.ychchan == 6) col = oklsh_to_rec2020(vec3(max(y+0.5,0),0.5,x)); // Yh
    else if(params.ychchan == 7) col = oklsh_to_rec2020(vec3(0.5,max(y+0.5,0),x)); // Ch
    else if(params.ychchan == 8) col = oklsh_to_rec2020(vec3(0.5,x,y)); // hC
    rgba = vec4(0.5*col, 1);
  }

  if(params.mode == 2)
  { // ych
    // channels mean, 0--8: YY CC hh YC CY hY Yh Ch hC
    // depending on Y: 0, 4, 5
    // depending on C: 1, 3, 8
    // depending on h: 2, 6, 7
    for(int cc=0;cc<3;cc++)
    { // draw all three curves depending on same variable
      int c; // find channel to display, depending on variable defined by dep:
      if(dep == 0)
      {
        if     (cc == 0) c = 0;
        else if(cc == 1) c = 4;
        else             c = 5;
      }
      else if(dep == 1)
      {
        if     (cc == 0) c = 1;
        else if(cc == 1) c = 3;
        else             c = 8;
      }
      else if(dep == 2)
      {
        if     (cc == 0) c = 2;
        else if(cc == 1) c = 6;
        else             c = 7;
      }
      vec3 col = vec3(0.9);
      float ddx;
      if(c == 0)
      { // splines on the diagonal
        const int cnt = params.cntr;
        float yl = curve_eval(c, e2l(x), ddx);
        float y = l2e(yl);
        if(params.edit > 0)
          ddx *= 1.0/(2.0*sqrt(yl)) * 2.0 * x; // compensate for e2l and l2e
        const float w = c == params.ychchan ? 5.0 : 2.0; // stroke width
        float t = w * sqrt(1.0 + ddx*ddx); // line thinckness along const y
        float d = abs((1.0+of0-y) * (1.0-of0) * imageSize(img_dspy).y - ipos.y);
        rgba = max(rgba, vec4(col, 0.2) * vec4(vec3(smoothstep(t, 0.0, d)), 1));
        if(c == params.ychchan)
        { // draw (selected) points
          off = of0 * imageSize(img_dspy).y;
          y = 1.0-ipos.y/float(imageSize(img_dspy).y - off);
          for(int i=0;i<cnt;i++)
          {
            vec2 dist = vec2(x,y)-vec2(l2e(curve_x(c, i)), l2e(curve_y(c, i)));
            d = dot(dist,dist);
            float rad = params.sel == i ? 0.03 : 0.02;
            if(d < rad*rad)
              rgba = mix(rgba, params.sel == i ? global.hov : global.col, smoothstep(rad, 0.0, d));
          }
        }
      }
      else
      {
        float y = curve_horiz(c, x, ddx);
        const float w = c == params.ychchan ? 5.0 : 2.0; // stroke width
        float t = w * sqrt(1.0 + ddx*ddx); // line thinckness along const y
        float d = abs((0.5+of0-y) * (1.0-of0) * imageSize(img_dspy).y - ipos.y);
        rgba = max(rgba, vec4(col, 0.2) * vec4(vec3(smoothstep(t, 0.0, d)), 1));
        if(c == params.ychchan)
        { // draw (selected) points
          off = of0 * imageSize(img_dspy).y;
          y = 0.5-ipos.y/float(imageSize(img_dspy).y - off);
          for(int i=0;i<6;i++)
          {
            vec2 dist = vec2(x,y)-vec2(eq_x(c, i), eq_y(c, i));
            d = dot(dist,dist);
            float rad = params.sel == i ? 0.03 : 0.02;
            if(d < rad*rad)
              rgba = mix(rgba, params.sel == i ? global.hov : global.col, smoothstep(rad, 0.0, d));
          }
        }
      }
    }
  }
  else
  { // rgb and luminance modes
    for(int c=0;c<3;c++)
    { // draw all three curves
      if(params.mode == 1) // luminance
        c = params.chan;
      const int cnt = c == 0 ? params.cntr : c == 1 ? params.cntg : params.cntb;
      vec3 col = params.mode == 1 ? vec3(0.9) : vec3(c==0?0.9:0.1,c==1?0.9:0.1,c==2?0.9:0.1);
      float ddx;
      float yl = curve_eval(c, e2l(x), ddx);
      float y = l2e(yl);
      if(params.edit > 0)
        ddx *= 1.0/(2.0*sqrt(yl)) * 2.0 * x; // compensate for e2l and l2e
      const float w = c == params.chan ? 5.0 : 2.0; // stroke width
      float t = w * sqrt(1.0 + ddx*ddx); // line thinckness along const y
      float d = abs((1.0+of0-y) * (1.0-of0) * imageSize(img_dspy).y - ipos.y);
      rgba = max(rgba, vec4(col, 0.2) * vec4(vec3(smoothstep(t, 0.0, d)), 1));
      if(c == params.chan)
      { // draw (selected) points
        off = of0 * imageSize(img_dspy).y;
        y = 1.0-ipos.y/float(imageSize(img_dspy).y - off);
        for(int i=0;i<cnt;i++)
        {
          vec2 dist = vec2(x,y)-vec2(l2e(curve_x(c, i)), l2e(curve_y(c, i)));
          d = dot(dist,dist);
          float rad = params.sel == i ? 0.03 : 0.02;
          if(d < rad*rad)
            rgba = mix(rgba, params.sel == i ? global.hov : global.col, smoothstep(rad, 0.0, d));
        }
      }
      if(params.mode == 1) // luminance
        break;
    }
  }
  imageStore(img_dspy, ipos, rgba);
}
