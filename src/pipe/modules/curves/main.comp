#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 1) uniform params_t
{
  vec4 abcdr[8];
  vec4 abcdg[8];
  vec4 abcdb[8];
  vec4 xr0, xr1;
  vec4 xg0, xg1;
  vec4 xb0, xb1;
  vec4 yr0, yr1;
  vec4 yg0, yg1;
  vec4 yb0, yb1;
  int  cntr, cntg, cntb;
  int  sel;
  int  mode;
  int  chan;
  int  ychchan;
  int  edit;
  int  pad0, pad1;
  float ddr0, ddrn;
  float ddg0, ddgn;
  float ddb0, ddbn;
  vec4 vtx[18]; // vertex locations for interpolated relative curves, max 6 per curve, 6 curves, 2 coords
  vec4 abcd0[6], abcd1[6], abcd2[6], abcd3[6], abcd4[6], abcd5[6];
} params;
layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;
#include "eq.glsl"
#include "spline.glsl"

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;
  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  float ddx;

  if(params.mode < 2)
  { // rgb or luminance
    rgb.r = curve_eval(params.mode == 1 ? params.chan : 0, rgb.r, ddx);
    rgb.g = curve_eval(params.mode == 1 ? params.chan : 1, rgb.g, ddx);
    rgb.b = curve_eval(params.mode == 1 ? params.chan : 2, rgb.b, ddx);
  }
  else
  { // ych
    // convert rec2020 rgb to yuv and lch from there
    vec3 ychi = rgb2ych(rgb);

    // now we move ych through the 3x3 curve system (ych x ych):
    // step 1: apply curves to the diagonal (y/y, c/c, h/h, these are diagonal lines or splines):
    vec3 ycho = vec3(
        curve_eval(0, ychi.r, ddx),
        curve_eval(1, ychi.g, ddx),
        curve_eval(2, ychi.b, ddx));

    // step 2: the off-diagonals: apply the remaining two dependencies. these are relative,
    // i.e. start from flat lines in the graphs. also these aren't splines but cosine interpolation (less ringing)
    ycho.r += curve_horiz(0, ychi.g, ddx); // y/c
    ycho.g += curve_horiz(1, ychi.r, ddx); // c/y
    ycho.b += curve_horiz(2, ychi.r, ddx); // h/y
    ycho.r += curve_horiz(3, ychi.b, ddx); // y/h
    ycho.g += curve_horiz(4, ychi.b, ddx); // c/h
    ycho.b += curve_horiz(5, ychi.g, ddx); // h/c

    ycho.g = max(ycho.g, 0.0); // no negative chroma, does weird shit

    // convert back: ych -> YCbCr -> rgb (rec2020)
    rgb = ych2rgb(ycho);
  }
  imageStore(img_out, ipos, vec4(rgb, 1));
}
