#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  vec4  crop;
  float mode;
} params;

layout( // input ui32 buffer r
    set = 1, binding = 0
) uniform usampler2D img_in_r;

layout( // input ui32 buffer r
    set = 1, binding = 1
) uniform usampler2D img_in_g;

layout( // input ui32 buffer r
    set = 1, binding = 2
) uniform usampler2D img_in_b;

layout( // output f16 buffer rgba
    set = 1, binding = 3
) uniform writeonly image2D img_out;

// display histogram, runs on output dimensions==input
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  int split = params.mode < 0.1 ? 1 : 3;
  ivec2 o_dim = imageSize(img_out);
  if(any(greaterThanEqual(ipos, ivec2(o_dim.x/split, o_dim.y)))) return;

  uint img_ht = texelFetch(img_in_b, ivec2(0, 0), 0).r;
  vec3 rgb = 1.0/float(img_ht)*vec3(texelFetch(img_in_r, ipos, 0).r,
                                    texelFetch(img_in_g, ipos, 0).r,
                                    texelFetch(img_in_b, ipos, 0).r);
  rgb = clamp(rgb, 0.0, 1.0);
  rgb = pow(rgb, vec3(0.5));
  if(params.mode < 0.1)
  {
    imageStore(img_out, ipos, vec4(rgb, 1.0));
  }
  else
  {
    int od = (int(imageSize(img_out).x)-1)/3;
    imageStore(img_out, ivec2(ipos.x, ipos.y), vec4(rgb.r, 0.0, 0.0, 1.0));
    imageStore(img_out, ivec2(od + ipos.x, ipos.y), vec4(0.0, rgb.g, 0.0, 1.0));
    imageStore(img_out, ivec2(2*od + ipos.x, ipos.y), vec4(0.0, 0.0, rgb.b, 1.0));
  }
}
