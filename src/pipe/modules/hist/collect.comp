#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  vec4  crop;
  float mode;
} params;

layout( // input f16 buffer rgb
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // output ui32 buffer r
    set = 1, binding = 1, r32ui
) uniform uimage2D img_out_r;

layout( // output ui32 buffer r
   set = 1, binding = 2, r32ui
) uniform uimage2D img_out_g;

layout( // output ui32 buffer r
   set = 1, binding = 3, r32ui
) uniform uimage2D img_out_b;


// histogram counter. this runs on the input dimensions
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, textureSize(img_in, 0)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  float scale = float(imageSize(img_out_r).x)/float(textureSize(img_in, 0).x);
  // should be replaced by a checkbox or combox on UI
  int split = params.mode < 0.1 ? 1 : 3;
  int opos = clamp(int(scale * ipos.x), 0, int(imageSize(img_out_r).x)-1)/split;
  vec3 y = clamp(vec3((1.0-rgb) * imageSize(img_out_r).y), 1, imageSize(img_out_r).y-1);

  imageAtomicAdd(img_out_r, ivec2(opos, y.r), 1);
  uint g_max = imageAtomicAdd(img_out_g, ivec2(opos, y.g), 1);
  imageAtomicAdd(img_out_b, ivec2(opos, y.b), 1);
  // ugly - just to pass the max count to map
  imageAtomicMax(img_out_b, ivec2(0, 0), g_max+1);
}
