#version 460
#extension GL_GOOGLE_include_directive    : enable
#include "shared.glsl"
#include "matrices.h"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(std140, set = 0, binding = 1) uniform params_t
{
  int primaries;
  int trc;
} params;

layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  if(params.primaries == 0)
  { // TODO: use uploaded custom matrix?
  }
#define CONV(I, P) \
  else if(params.primaries == I)\
  {\
    const mat3 M = matrix_rec2020_to_ ## P;\
    rgb = M * rgb; \
  }
  CONV(1, rec709)
  CONV(3, adobergb)
  CONV(4, p3d65)
  CONV(5, xyz)
  CONV(6, ap0)
  CONV(7, ap1)
  CONV(10, redwg)
#undef CONV
  // the other primaries are more like input spaces, we don't want to output them.

  // if(params.trc == 0) // linear
  if(params.trc == 1) // 709
  {
    const float a = 1.09929682680944;
    const float b = 0.018053968510807;
    rgb = mix(rgb * 4.5, pow(rgb, vec3(1.0/2.2))*a - (a - 1), greaterThan(rgb, vec3(b)));
  }
  else if(params.trc == 2) // sRGB
  {
    rgb = mix(rgb * 12.92, pow(rgb, vec3(1.0/2.4))*1.055-0.055, greaterThan(rgb, vec3(0.0031308)));
  }
  else if(params.trc == 3) // PQ
  { // oetf
    const float c3 = 2392.0/128.0;
    const float c2 = 2413.0/128.0;
    const float c1 = c3-c2+1.0;
    const float m1 = 1305.0/8192.0;
    const float m2 = 2523.0/32.0;
    // zimg says:
    // More stable arrangement that avoids some cancellation error.
    rgb = max(vec3(0.0), rgb);
    rgb = pow(rgb, vec3(m1));
    vec3 num = (c1 - 1.0) + (c2 - c3) * rgb;
    vec3 den = 1.0 + c3 * rgb;
    rgb = pow(1.0 + num / den, vec3(m2));
  }
  else if(params.trc == 4) // DCI
  {
    rgb = pow(rgb, vec3(1.0/2.6));
  }
  else if(params.trc == 5) // HLG
  {
    const float a = 0.17883277, b = 1.0-4.0*a, c = 0.5 - a*log(4.0*a);
    rgb = mix(sqrt(3.0*rgb), a*log(12.0*rgb-b) + c, greaterThan(rgb, vec3(1.0/12.0)));
  }
  else if(params.trc == 6) // gamma
  { // TODO get gamma from params
    rgb = pow(rgb, vec3(1.0/2.2)); // happens to be adobe rgb
  }

  imageStore(img_out, ipos, vec4(rgb, 1.0));
}
