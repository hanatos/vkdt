/* OpenDRT v1.1.0 -------------------------------------------------

   Written by Jed Smith
https://github.com/jedypod/open-display-transform
License: GPLv3
-------------------------------------------------*/
#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
#include "params.glsl"
#include "opendrt.glsl"
layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;

void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;
  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;

  /*****************************************************
    Parameter Setup
    --------------------------------------------------*/

#if 0
  // Init look preset variables
  int tn_hcon_enable, tn_lcon_enable, pt_enable, ptl_enable, ptm_enable, brl_enable, brlp_enable, hc_enable, hs_rgb_enable, hs_cmy_enable, cwp, tn_su, clamp, display_gamut, eotf;
  
  float tn_con, tn_sh, tn_toe, tn_off, tn_hcon, tn_hcon_pv, tn_hcon_st, tn_lcon, tn_lcon_w, cwp_lm, rs_sa, rs_rw, rs_bw, pt_lml, pt_lml_r, pt_lml_g, pt_lml_b, pt_lmh, pt_lmh_r, pt_lmh_b, ptl_c, ptl_m, ptl_y, ptm_low, ptm_low_rng, ptm_low_st, ptm_high, ptm_high_rng, ptm_high_st, brl, brl_r, brl_g, brl_b, brl_rng, brl_st, brlp, brlp_r, brlp_g, brlp_b, hc_r, hc_r_rng, hs_r, hs_r_rng, hs_g, hs_g_rng, hs_b, hs_b_rng, hs_c, hs_c_rng, hs_m, hs_m_rng, hs_y, hs_y_rng;
#endif

  mat3 in_to_xyz;
  if (params.i_gamut==0) in_to_xyz = mat3(1);
  else if (params.i_gamut==1) in_to_xyz = matrix_ap0_to_xyz;
  else if (params.i_gamut==2) in_to_xyz = matrix_ap1_to_xyz;
  else if (params.i_gamut==3) in_to_xyz = matrix_p3d65_to_xyz;
  else if (params.i_gamut==4) in_to_xyz = matrix_rec2020_to_xyz;
  else if (params.i_gamut==5) in_to_xyz = matrix_rec709_to_xyz;
  else if (params.i_gamut==6) in_to_xyz = matrix_arriwg3_to_xyz;
  else if (params.i_gamut==7) in_to_xyz = matrix_arriwg4_to_xyz;
  else if (params.i_gamut==8) in_to_xyz = matrix_redwg_to_xyz;
  else if (params.i_gamut==9) in_to_xyz = matrix_sonysgamut3_to_xyz;
  else if (params.i_gamut==10) in_to_xyz = matrix_sonysgamut3cine_to_xyz;
  else if (params.i_gamut==11) in_to_xyz = matrix_vgamut_to_xyz;
  else if (params.i_gamut==12) in_to_xyz = matrix_egamut_to_xyz;
  else if (params.i_gamut==13) in_to_xyz = matrix_egamut2_to_xyz;
  else if (params.i_gamut==14) in_to_xyz = matrix_davinciwg_to_xyz;

  float crv_tsn = 0.0;
  vec2 pos = ipos;
  vec2 res = imageSize(img_out);

  // x-position based input value for tonescale overlay
  if (params.crv_en == 1) crv_tsn = oetf_filmlight_tlog(pos.x/res.x);

  // Linearize if a non-linear input oetf / transfer function is selected
  rgb = linearize(rgb, params.i_oetf);


  /***************************************************
    Tonescale Constraint Calculations
    https://www.desmos.com/calculator/1c4fhzy3bw

    These should be pre-calculated but there is no way to do this in DCTL.
    Anything that is const should be precalculated and not run per-pixel
    --------------------------------------------------*/
  const float ts_x1 = pow(2.0f, 6.0f*params.tn_sh + 4.0f);
  const float ts_y1 = params.tn_Lp/100.0f;
  const float ts_x0 = 0.18f + params.tn_off;
  const float ts_y0 = params.tn_Lg/100.0f*(1.0f + params.tn_gb*log2(ts_y1));
  const float ts_s0 = compress_toe_quadratic(ts_y0, params.tn_toe, 1);
  const float ts_p = params.tn_con/(1.0f + params.tn_su*0.05f); // unconstrained surround compensation
  const float ts_s10 = ts_x0*(pow(ts_s0, -1.0f/params.tn_con) - 1.0f);
  const float ts_m1 = ts_y1/pow(ts_x1/(ts_x1 + ts_s10), params.tn_con);
  const float ts_m2 = compress_toe_quadratic(ts_m1, params.tn_toe, 1);
  const float ts_s = ts_x0*(pow(ts_s0/ts_m2, -1.0f/params.tn_con) - 1.0f);
  const float ts_dsc = params.eotf==4 ? 0.01 : params.eotf==5 ? 0.1 : 100.0f/params.tn_Lp;

  // Lerp from pt_cmp at 100 nits to pt_cmp_hdr at 1000 nits
  const float pt_cmp_Lf = params.pt_hdr*min(1.0f, (params.tn_Lp - 100.0f)/900.0f);
  // Approximate scene-linear scale at Lp=100 nits
  const float s_Lp100 = ts_x0*(pow((params.tn_Lg/100.0f), -1.0f/params.tn_con) - 1.0f);
  const float ts_s1 = ts_s*pt_cmp_Lf + s_Lp100*(1.0f - pt_cmp_Lf);


  // Convert from input gamut into P3-D65
  rgb = in_to_xyz * rgb;
  rgb = matrix_xyz_to_p3d65 * rgb;


  // Rendering Space: "Desaturate" to control scale of the color volume in the rgb ratios.
  // Controlled by rs_sa (saturation) and red and blue weights (rs_rw and rs_bw)
  vec3 rs_w = vec3(params.rs_rw, 1.0f - params.rs_rw - params.rs_bw, params.rs_bw);
  float sat_L = dot(rgb, rs_w);
  rgb = sat_L*params.rs_sa + rgb*(1.0f - params.rs_sa);


  // Offset
  rgb += params.tn_off;
  if (params.crv_en == 1) crv_tsn += params.tn_off;


  // Tonescale Norm
  float tsn = hypotf3(rgb)/SQRT3;

  // RGB Ratios
  rgb = mix(rgb/tsn, vec3(0.0f), bvec3(tsn==0.0));
  
  vec2 opp = opponent(rgb);
  float ach_d = hypotf2(opp)/2.0f;
  
  // Smooth ach_d, normalized so 1.0 doesn't change https://www.desmos.com/calculator/ozjg09hzef
  ach_d = (1.25f)*compress_toe_quadratic(ach_d, 0.25f, 0);

  // Hue angle, rotated so that red = 0.0
  float hue = mod(atan(opp.x, opp.y) + M_PI + 1.10714931f, 2.0f*M_PI);

  // RGB Hue Angles
  // Wider than CMY by default. R towards M, G towards Y, B towards C
  vec3 ha_rgb = vec3(
    gauss_window(hue_offset(hue, 0.1f), 0.66f),
    gauss_window(hue_offset(hue, 4.3f), 0.66f),
    gauss_window(hue_offset(hue, 2.3f), 0.66f));
    
  // RGB Hue Angles for hue shift: red shifted more orange
  vec3 ha_rgb_hs = vec3(
    gauss_window(hue_offset(hue, -0.4f), 0.66f),
    ha_rgb.y,
    gauss_window(hue_offset(hue, 2.5f), 0.66f));
  
  // CMY Hue Angles
  // Exact alignment to Cyan/Magenta/Yellow secondaries would be M_PI, M_PI/3 and -M_PI/3, but
  // we customize these a bit for creative purposes: M towards B, Y towards G, C towards G
  vec3 ha_cmy = vec3(
    gauss_window(hue_offset(hue, 3.3f), 0.5f),
    gauss_window(hue_offset(hue, 1.3f), 0.5f),
    gauss_window(hue_offset(hue, -1.15f), 0.5f));


  // Brilliance
  if(params.brl_en == 1)
  {
    float brl_tsf = pow(tsn/(tsn + 1.0f), 1.0f - params.brl_rng);
    float brl_exf = (params.brl + params.brl_r*ha_rgb.x + params.brl_g*ha_rgb.y + params.brl_b*ha_rgb.z)*pow(ach_d, 1.0f/params.brl_st);
    float brl_ex = pow(2.0f, brl_exf*(brl_exf < 0.0f ? brl_tsf : 1.0f - brl_tsf));
    tsn *= brl_ex;
  }

  // Contrast Low 
  if(params.tn_lc_en == 1)
  {
    float lcon_m = pow(2.0f, -params.tn_lc);
    float lcon_w = params.tn_lc_w/4.0f;
    lcon_w *= lcon_w;
    
    // Normalize for ts_x0 intersection constraint: https://www.desmos.com/calculator/blyvi8t2b2
    const float lcon_cnst_sc = compress_toe_cubic(ts_x0, lcon_m, lcon_w, 1)/ts_x0;
    tsn *= lcon_cnst_sc;
    tsn = compress_toe_cubic(tsn, lcon_m, lcon_w, 0);
    
    if (params.crv_en == 1) crv_tsn = compress_toe_cubic(crv_tsn*lcon_cnst_sc, lcon_m, lcon_w, 0);
  }

  // Contrast High
  if (params.tn_hc_en == 1)
  {
    float hcon_p = pow(2.0f, params.tn_hc);
    tsn = contrast_high(tsn, hcon_p, params.tn_hc_pv, params.tn_hc_st, 0);
    
    if (params.crv_en == 1) crv_tsn = contrast_high(crv_tsn, hcon_p, params.tn_hc_pv, params.tn_hc_st, 0);
  }

  // Hyperbolic Compression
  float tsn_pt = compress_hyperbolic_power(tsn, ts_s1, ts_p);
  float tsn_const = compress_hyperbolic_power(tsn, s_Lp100, ts_p);
  tsn = compress_hyperbolic_power(tsn, ts_s, ts_p);
  
  float crv_tsn_const = 0.0f;
  if (params.crv_en == 1) {
    crv_tsn_const = compress_hyperbolic_power(crv_tsn, s_Lp100, ts_p);
    crv_tsn = compress_hyperbolic_power(crv_tsn, ts_s, ts_p);
  }



  /***************************************************
    Hue Contrast R
  --------------------------------------------------*/
  if (params.hc_en == 1)
  {
    float hc_ts = 1.0f - tsn_const;
    // Limit high purity on bottom end and low purity on top end by ach_d.
    // This helps reduce artifacts and over-saturation.
    float hc_c = hc_ts*(1.0f - ach_d) + ach_d*(1.0f - hc_ts);
    hc_c *= ach_d*ha_rgb.x;
    hc_ts = pow(hc_ts, 1.0f/params.hc_r_r);
    // Bias contrast based on tonescale using Lift/Mult: https://www.desmos.com/calculator/gzbgov62hl
    float hc_f = params.hc_r*(hc_c - 2.0f*hc_c*hc_ts) + 1.0f;
    rgb = vec3(rgb.x, rgb.y*hc_f, rgb.z*hc_f);
  }



  /***************************************************
    Hue Shift
  --------------------------------------------------*/
  // Hue Shift RGB by purity compress tonescale, shifting more as intensity increases
  if (params.hsrgb_en == 1)
  {
    vec3 hs_rgb = vec3(
      ha_rgb_hs.x*ach_d*pow(tsn_pt, 1.0f/params.hs_r_r),
      ha_rgb_hs.y*ach_d*pow(tsn_pt, 1.0f/params.hs_g_r),
      ha_rgb_hs.z*ach_d*pow(tsn_pt, 1.0f/params.hs_b_r));
    vec3 hsf = vec3(hs_rgb.x*params.hs_r, hs_rgb.y*-params.hs_g, hs_rgb.z*-params.hs_b);
    hsf = vec3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }

  // Hue Shift CMY by tonescale, shifting less as intensity increases
  if (params.hscmy_en == 1)
  {
    float tsn_pt_compl = 1.0f - tsn_pt;
    vec3 hs_cmy = vec3(
      ha_cmy.x*ach_d*pow(tsn_pt_compl, 1.0f/params.hs_c_r),
      ha_cmy.y*ach_d*pow(tsn_pt_compl, 1.0f/params.hs_m_r),
      ha_cmy.z*ach_d*pow(tsn_pt_compl, 1.0f/params.hs_y_r));
    vec3 hsf = vec3(hs_cmy.x*-params.hs_c, hs_cmy.y*params.hs_m, hs_cmy.z*params.hs_y);
    hsf = vec3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }


  /***************************************************
    Purity Compression
      https://www.desmos.com/calculator/adtzkjofgn
  --------------------------------------------------*/
  // Purity Limit Low
  float pt_lml_p = 1.0f + 4.0f*(1.0f - tsn_pt)*(params.pt_lml + params.pt_lml_r*ha_rgb_hs.x + params.pt_lml_g*ha_rgb_hs.y + params.pt_lml_b*ha_rgb_hs.z);
  float ptf = 1.0f - pow(tsn_pt, pt_lml_p);
  
  // Purity Limit High
  float pt_lmh_p = (1.0f - ach_d*(params.pt_lmh_r*ha_rgb_hs.x + params.pt_lmh_b*ha_rgb_hs.z))*(1.0f - params.pt_lmh*ach_d);
  ptf = pow(ptf, pt_lmh_p);

  
  /***************************************************
    Mid-Range Purity
      This boosts mid-range purity on the low end
      and reduces mid-range purity on the high end
  --------------------------------------------------*/
  if (params.ptm_en == 1)
  {
    float ptm_low_f;
    if (params.ptm_lo_s == 0.0f || params.ptm_lo_r == 0.0f) ptm_low_f = 1.0f;
    else ptm_low_f = 1.0f + params.ptm_lo*exp(-2.0f*ach_d*ach_d/params.ptm_lo_s)*pow(1.0f - tsn_const, 1.0f/params.ptm_lo_r);
    float ptm_high_f;
    if (params.ptm_hi_s == 0.0f || params.ptm_hi_r == 0.0f) ptm_high_f = 1.0f;
    else ptm_high_f = 1.0f + params.ptm_hi*exp(-2.0f*ach_d*ach_d/params.ptm_hi_s)*pow(tsn_pt, 1.0f/(4.0f*params.ptm_hi_r));
    ptf *= ptm_low_f*ptm_high_f;
  }

  // Lerp to peak achromatic by ptf in rgb ratios
  rgb = rgb*ptf + 1.0f - ptf;

  // Inverse Rendering Space
  sat_L = rgb.x*rs_w.x + rgb.y*rs_w.y + rgb.z*rs_w.z;
  rgb = (sat_L*params.rs_sa - rgb)/(params.rs_sa - 1.0f);

  // Convert to final display gamut and set whitepoint
  rgb = display_gamut_whitepoint(rgb, tsn_const, params.cwp_lm, params.o_gamut, params.cwp);

  
  // Post Brilliance
  if (params.brlp_en == 1)
  {
    vec2 brlp_opp = opponent(rgb);
    float brlp_ach_d = hypotf2(brlp_opp)/4.0f;
    // brlp_ach_d = 1.0f - gauss_window(brlp_ach_d, 8.0f);
    brlp_ach_d = 1.1f*(brlp_ach_d*brlp_ach_d/(brlp_ach_d + 0.1f));
    vec3 brlp_ha_rgb = ach_d*ha_rgb;
    float brlp_m = params.brlp + params.brlp_r*brlp_ha_rgb.x + params.brlp_g*brlp_ha_rgb.y + params.brlp_b*brlp_ha_rgb.z;
    float brlp_ex = pow(2.0f, brlp_m*brlp_ach_d*tsn);
    rgb *= brlp_ex;
  }

  // Purity Compress Low
  if (params.ptl_en == 1) rgb = vec3(softplus(rgb.x, params.ptl_c), softplus(rgb.y, params.ptl_m), softplus(rgb.z, params.ptl_y));
 
  // Final tonescale adjustments
  tsn *= ts_m2; // scale for inverse toe
  tsn = compress_toe_quadratic(tsn, params.tn_toe, 0);
  tsn *= ts_dsc; // scale for display encoding
  
  if (params.crv_en == 1) {
    crv_tsn *= ts_m2;
    crv_tsn = compress_toe_quadratic(crv_tsn, params.tn_toe, 0);
    crv_tsn *= ts_dsc;
    // scale to 1.0 = 1000 nits for st2084 PQ
    if (params.eotf == 4) crv_tsn *= 10.0f;
  }

  vec3 crv_rgb = vec3(crv_tsn);
  if (params.crv_en == 1) crv_rgb = display_gamut_whitepoint(crv_rgb, crv_tsn_const, params.cwp_lm, params.o_gamut, params.cwp);


  // Return from RGB ratios
  rgb *= tsn;

  // Rec.2020 (P3 Limited)
  if (params.o_gamut==2) {
    rgb = max(rgb, vec3(0.0)); // Limit to P3 gamut
    rgb = matrix_p3_to_rec2020 * rgb;
  }
  
  // Clamp
  if (params.clmp == 1) rgb = clamp(rgb, vec3(0.0), vec3(1.0));

  // Apply inverse Display EOTF
  float eotf_p = 2.0f + params.eotf * 0.2f;
  if ((params.eotf > 0) && (params.eotf < 4)) rgb = pow(rgb, vec3(1.0/eotf_p));
  else if (params.eotf == 4) rgb = eotf_pq(rgb, 1);
  else if (params.eotf == 5) rgb = eotf_hlg(rgb, 1);
  
  if (params.crv_en == 1) {
    if ((params.eotf > 0) && (params.eotf < 4)) crv_rgb = pow(crv_rgb, vec3(1.0f/eotf_p));
    else if (params.eotf == 4) crv_rgb = eotf_pq(crv_rgb, 1);
    else if (params.eotf == 5) crv_rgb = eotf_hlg(crv_rgb, 1);
  }
  
  
  // Draw tonescale overlay
  if (params.crv_en == 1)
  {
    vec3 crv_rgb_dst = vec3(res.y-pos.y-crv_rgb.x*res.y, res.y-pos.y-crv_rgb.y*res.y, res.y-pos.y-crv_rgb.z*res.y);
    float crv_w0 = 0.35f; // width of tonescale overlay
    crv_rgb_dst.x = exp(-crv_rgb_dst.x*crv_rgb_dst.x*crv_w0);
    crv_rgb_dst.y = exp(-crv_rgb_dst.y*crv_rgb_dst.y*crv_w0);
    crv_rgb_dst.z = exp(-crv_rgb_dst.z*crv_rgb_dst.z*crv_w0);
    float crv_lm = params.eotf < 4 ? 1.0f : 1.0f; // reduced luminance in hdr
    crv_rgb_dst = clamp(crv_rgb_dst, vec3(0.0), vec3(1.0));
    rgb = rgb * (1.0f - crv_rgb_dst) + vec3(crv_lm, crv_lm, crv_lm)*crv_rgb_dst;
  }
  
  imageStore(img_out, ipos, vec4(rgb, 1));
}
