#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable

#include "shared.glsl"
#include "shared/munsell.glsl"
#include "shared/dtucs.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float brightness;
  float contrast;
  float bias;
  int   colourmode;
} params;

layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;
layout(set = 1, binding = 2) uniform writeonly image2D img_crv;

float
weibull_cdf(
    float x,  // input value (0, infty)
    float il, // weibull 1.0/lambda, scale parameter (0, infty)
    float k)  // weibull k, shape parameter          (0, infty)
{
  return 1.0 - exp(-pow(max(x, 1e-7)*il, k));
}

float // derivative of cdf:
weibull_pdf(float x, float il, float k)
{
  x = max(x, 1e-7);
  return k*il * pow(x*il, k-1.0) * exp(-pow(x*il, k));
}
vec3 // vector version
weibull_cdf(vec3 x, float il, float k)
{
  return 1.0 - exp(-pow(max(x, 1e-7)*il, vec3(k)));
}

float lerp_chromaticity_angle(float h1, float h2, float t)
{
    float delta = h2 - h1;
    if (delta > M_PI)
    {
        h2 -= 2.0 * M_PI;  // Go the reverse direction
    }
    else if (delta < -M_PI)
    {
        h2 += 2.0 * M_PI;  // Go the reverse direction
    }
    float lerped = h1 + t * (h2 - h1);
    return mod(lerped, 2.0 * M_PI);  // Wrap around at 2*pi
}


vec3 
agx(vec3 color, float il, float k)
{
	// AgX inset and outset constants
  // generated from https://github.com/EaryChow/AgX_LUT_Gen/blob/main/AgXBaseRec2020.py
	const mat3 agx_mat = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 agx_mat_inv = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	color = agx_mat * color;

  // similar hack to https://github.com/EaryChow/AgX_LUT_Gen/blob/main/AgXBaseRec2020.py
  float mix_percent = 0.4;
  vec3 color0_hsv = rgb2hsv(color);

	// Apply curve
  color = weibull_cdf(color, il, k);
  
  vec3 color1_hsv = rgb2hsv(color);
  color1_hsv[0] = lerp_chromaticity_angle(color0_hsv[0], color1_hsv[0], mix_percent);
  color = hsv2rgb(color1_hsv);

	color = agx_mat_inv * color;

	return color;
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  float il = max(5e-3, params.brightness);
  float k  = max(1e-5, params.contrast);
  vec3 col0 = texelFetch(img_in, ipos, 0).rgb;
  col0 += params.bias;
  vec3 col1;
  if(params.colourmode == 0)
  { // colour using aurelien's patented ucs:
    const mat3 xyz_to_rec2020 = mat3(
        1.7166511880, -0.6666843518, 0.0176398574, 
        -0.3556707838, 1.6164812366, -0.0427706133, 
        -0.2533662814, 0.0157685458, 0.9421031212);
    col1 = weibull_cdf(col0, il, k);
    vec3 xyz0 = inverse(xyz_to_rec2020) * col0;
    vec3 xyz1 = inverse(xyz_to_rec2020) * col1;
    vec3 xyY0 = vec3(xyz0.xy / max(1e-4, dot(vec3(1),xyz0)), xyz0.y);
    vec3 xyY1 = vec3(xyz1.xy / max(1e-4, dot(vec3(1),xyz1)), xyz0.y);
    const float L_white = 1.0;
    vec3 jch0 = xyY_to_dt_UCS_JCH(xyY0, L_white);
    vec3 jch1 = xyY_to_dt_UCS_JCH(xyY1, L_white);
    jch1 = vec3(jch1.x, jch1.y, jch0.z);
    xyY1 = dt_UCS_JCH_to_xyY(jch1, L_white);
    xyz1 = vec3(xyY1.xy, 1.0-xyY1.x-xyY1.y) * xyz1.y / max(1e-4,xyY1.y);
    col1 = xyz_to_rec2020 * xyz1;
  }
  else if(params.colourmode == 2)
  { // colour reconstruction using munsell hue constancy.
    col1 = weibull_cdf(col0, il, k);
    vec3 xyY0 = rec2020_to_xyY(col0);
    vec2 m0   = munsell_from_xy(xyY0.xy);
    vec3 xyY1 = rec2020_to_xyY(col1);
    vec2 m1   = munsell_from_xy(xyY1.xy);
    xyY1.xy   = munsell_to_xy(vec2(m0.x, m1.y));
    col1 = xyY_to_rec2020(xyY1);
  }
  else if(params.colourmode == 3)
  { // simple rgb/hsv hack:
    col1 = weibull_cdf(col0, il, k);
    col1 = adjust_colour_dng(col0, col1);
  }
  else if(params.colourmode == 1)
  { // apply per channel
    col1 = weibull_cdf(col0, il, k);
  }
  else if (params.colourmode == 4)
  { // agx tone mapping
    col1 = agx(col0, il, k);
  }

  if(all(lessThan(ipos, imageSize(img_crv))))
  {
    vec4 col_crv = vec4(0, 0, 0, 1);
    float of0 = 0;//0.1; // extend range outside [0,1]?
    float off = of0 * imageSize(img_crv).x;
    float x = ipos.x/float(imageSize(img_crv).x - off);
    float y = weibull_cdf(x, il, k);
    float ddx = weibull_pdf(x, il, k);
    const float w = 2.0; // stroke width
    float t = w * sqrt(1.0 + ddx*ddx); // line thinckness along const y
    float d = abs((1.0+of0-y) * (1.0-of0) * imageSize(img_crv).y - ipos.y);
    col_crv = max(col_crv, 0.2 * vec4(vec3(smoothstep(t, 0.0, d)), 1));
    imageStore(img_crv, ipos, col_crv);
  }

  imageStore(img_out, ipos, vec4(col1, 1));
}

